.1 缓存技术的思想
将一些经常使用数据（从数据库中查出后）保存在内存中，当再次想要获得这些数据时，就可以直接从内存中返回。

4.2 读模式和写模式
● 读模式：当服务端收到一个查询请求时，会先去查缓存，如果缓存命中，就直接从缓存中返回查询结果；如果缓存不命中，就去查数据库，然后将查询结果写入缓存。

     ● 写模式：当服务端收到一个修改请求时，在修改数据库中的数据后，需要对缓存中的数据做同步修改。

4.3 缓存过期
我们在内存中创建缓存记录时，如果不对其设置超时时间，除非手动删除，这条记录将永远存在于内存中，很容易造成内存泄漏。

    实现缓存过期的方式有两种：被动方式和主动方式。两种方式需要结合起来使用。

     ● 被动方式：当服务端收到查询请求去查缓存时，如果查到的是一条已过期的缓存记录，就删掉这条记录。

     ● 主动方式：每隔一段时间，随机选取一些缓存记录进行查验，删除其中已过期的记录。

4.4 缓存穿透、缓存雪崩和缓存击穿
● 缓存穿透：当客户端请求一些数据库中不存在的数据时，如果不把查询的空结果写入缓存，那么对这些数据的请求每次都会打到数据库，缓存就失去了意义。

        解决方法：将查询数据库得到的空结果写入缓存。

     ● 缓存雪崩：在高并发场景下，某一时刻，大量缓存记录同时失效，对这些缓存数据的请求会在一瞬间全部被打到数据库，数据库很可能会因瞬时压力过大而崩溃。

        解决方法：设置缓存记录的超时时间时，在设定时间的基础上增加一个随机时长。

     ● 缓存击穿：一些"热点"数据，在某个时刻，可能会被许多客户端同时请求，如果此时缓存记录正好失效，大量的查询请求会全部被打到数据库，可能导致数据库崩溃。

        解决方法：加锁。同一时间只允许一个线程进行查询，其他线程需要等待。

4.5 缓存一致性问题
缓存一致性问题指的是：数据库中的数据更新后，缓存中的数据要和数据库中保持一致。

    为什么这会是一个问题？

    数据库中的数据更新、缓存数据同步更新，两个步骤不能通过一个原子操作完成，这样在高并发场景就可能出现各种问题。

    从设计的角度来讲，我们放入缓存的数据不应该是对实时性、一致性要求很高的数据，所以我们只要做到下面两点就可以满足大部分业务场景了：

1) 设置缓存超时时间。

2) 数据库中的数据更新后删除缓存。

   如果一定要解决缓存一致性问题，业内通常有两种解决方案：

1) 延时双删。

   删除缓存记录 => 更新数据库数据 => 等待1~5s => 再次删除缓存记录

   ● 为什么要删除缓存记录而不是直接更新？

        多个线程先后更新数据库数据后，它们不一定会按顺序更新缓存数据，而删除操作不会受到顺序影响。

   ● 更新数据库数据前为什么要删除缓存数据？

        防止数据库数据更新成功后，某些原因导致缓存数据删除失败，缓存数据失真。

   ● 更新数据库数据后为什么要删除缓存数据？

        更新数据库数据前，可能有其他线程查到了旧数据，在更新数据库数据后，又将旧数据写入了缓存。

   ● 为什么要等待1~5s？

        等待查到旧数据的线程向缓存写数据完成、等待数据库主从复制完成。

2) 订阅数据库变更日志。

   当数据库中的数据被修改时，数据库生成一条变更日志（Binlog），我们可以订阅变更日志，拿到具体的变更操作，据此删除对应的缓存记录。

   目前比较成熟的订阅数据库变更日志的开源中间件：Canal。

   注意，无论是延时双删策略还是订阅数据库变更日志策略，都只能保证缓存的最终一致性，不能保证强一致性。对实时性要求较高的数据，就应该直接去查数据库。

4.6 保证原子操作
我们希望能够组合多个命令，让这些命令能够在一个原子操作内执行。

    Redis给出的解决方案是：支持执行Lua脚本。